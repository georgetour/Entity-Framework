
<h1>LINQ</h1>

<section>
<h2>What is LINQ?</h2
<p>LINQ stands for Language Integrated Query. It was invented by microsoft so you can query objects.
But also you can queries XML, any relational DBs and NoSQL DBs like mongodb. No matter what 
the source is you will use the exact same code to write queries. With LINQ the queries will be automatically
translated in the language that is supported by the data store.
</p>

<h3>LINQ and Entity framework</h3>

<ol>
<li>No more SQL queries/stored procedures(we can use pure C# CODE)</li>
<li>Increased productivity(don't have to change languages according to environment)</li>
<li>Though LINQ is powerful you will have eventually to use SQL queries for something more complicated</li>

</ol>



</section>

<section>
<h2>Getting data from database</h2>
<ol>
<li>first use the namespace using System.Linq;</li>
<li>Create an instance of our Db context
<pre>var context = new PlutoContext();</pre>

</li>
<li><strong>LINQ syntax(better for programmers who are used in SQL queries)</strong><br>
<pre>
            var query =
                from c in context.Courses
                where c.Name.Contains("c#")
                orderby c.Name
                select c;

            foreach (var item in query)
            {
                Console.WriteLine("C# related courses are :" + item.Name);
            }</pre>

<ol>
<li>from and in are LINQ keywords/operators</li>
<li>c temporary variable for our queries</li>
<li>then context.Courses is the source of our data</li>
<li>last line always select</li>
<li>So with the above code we are saying from table courses, that have in their name C#, order by Name and then
we iterate and display all courses in console
</li>
</ol>
</li>
<li><strong>Restriction operators ...where...</strong>
<pre>           var query2 =
                from c in context.Courses
                where c.Level == 1 && c.Author.Id == 1
                select c;</pre>


</li>

<li><strong>Ordering ...orderby...</strong>
<pre>           var query3 =
                from c in context.Courses
                where  c.Author.Id == 1
				orderby c.Level descending, c.Name
                select c;</pre>


</li>

<li><strong>Projection(return only specific properties/columns by anonymous types)in a new class that only has in our
example Name and Author</strong>
<pre>           var query4 =
                from c in context.Courses
                where  c.Author.Id == 1
				orderby c.Level descending, c.Name
                select new{Name = c.Name, Author = c.Author.Name};</pre>


</li>

<li><strong>Grouping ...group by into...(it's different from the one we use in SQL,it is used to break down
a list of objects into one or more groups, we declare a new variable that will have the group. The result
is a list of groups which eah group is an enum)</strong>
<pre>            var query5 =
                from c in context.Courses
                group c by c.Level into g
                select g;
				
            foreach (var group in query5)
            {
                Console.WriteLine(group.Key);

                foreach (var course in group)
                {
                    Console.WriteLine("\t{0}",course.Name);
                }
            }</pre>
It returns the groups by level<br>
<img src="group_by.jpg"><br>
<div>Or if we want to see how many each group has:</div>
<pre>
Console.WriteLine("{0} {1}",group.Key,group.Count());
</pre>
</li>

<li><strong>Joining ...Inner Join...Group Join...Cross Join...
(With LINQ you don't have to use an Inner Join)</strong>
<pre>	    //Inner join     
	    var query6 =
                from c in context.Courses
                select new { CourseName = c.Name, AuthorName = c.Author.Name };

            foreach (var course in query6)
            {
                Console.WriteLine(course.CourseName);
                Console.WriteLine(course.AuthorName);
            }
			
	    //Same as above if we don't have the relation in our entity model
            var query6 =
                from c in context.Courses
                join a in context.Authors on c.AuthorId equals a.Id
                select new { CourseName = c.Name, AuthorName = a.Name };
</pre>
</li>

<li><strong>...Group Join...
It's used like left join(SELECT A.Name From Authors A LEFT JOIN Courses C ON A.AuthorID = C.AuthorID</strong>
<pre>            //Group join
            //How many courses each author has 
            var query7 =
                from a in context.Authors
                join c in context.Courses on a.Id equals c.AuthorId into g
                select new { AuthorName = a.Name, Courses = g.Count() };

            foreach (var x in query7)
            {
                Console.WriteLine("{0} {1}",x.AuthorName,x.Courses);
                
            }
</pre>


</li>

<li><strong>...Cross Join or Cartesian Join...
It's used like cross join in SQL</strong>
<pre>            var query8 =
                from a in context.Authors
                from c in context.Courses
                select new { AuthorName = a.Name, CourseName = c.Name };

            foreach (var x in query8)
            {
                Console.WriteLine("{0} {1}", x.AuthorName, x.CourseName);

            }
</pre>


</li>



<li><strong>Extension methods(better for programmers who are used in lambda expressions, delegates, actions.
Also some queries can't be written with LINQ syntax so you have to use this approach)</strong>

<pre>
            var courses = context.Courses
                .Where(c => c.Name
                .Contains("c#"))
                .OrderBy(c => c.Name);

            foreach (var course in courses)
            {
                Console.WriteLine("C# related courses are :" + course.Name);
            }

</pre></li>
</ol>



</section>
