
<h1>Overriding Conventions</h1>
<section>
<h2>Data annotation</h2>
<p>Let's say we have a nullable convention like shown here.
<img src="overriding_convention.jpg">
We want to override this convention and make sure that every course has a description.
We go to CodeFirstExistingDatabase at Course class.
<pre>
[Required]
public string Description { get; set; }
</pre>
</p>

<p>Also we need using System.ComponentModel.DataAnnotations; </p>
<p>Back to package manager console to add the migration and we see what the migration created.

<img src="nullable_false_created.jpg">
</p>

<p>If we want this change we apply the migration by updating database.</p>

<h3>Table Names</h3>
<p>If you have a class Course the table name must be Courses. You can define the Schema
also if it isn't in dbo.</p>
<pre>
  [Table("Courses").Schema ="catalog"]
  public partial class Course
</pre>

<h3>Column Names</h3>
<p>The convention assumes the property is the same with the column.
If you want to use different table name and different type you wil have the following code.
</p>
<pre>
  [Column("sName",TypeName="varchar")]
  public string Name {get; set;}
</pre>

<h3>Primary Key</h3>
<p>The convention assumes that if you have a property Id or the nameo of the class plus Id
it will be the primary key. It s an integer and identity column. If we have something like ISBN we
need to tell entity framework that this property will be the Id. Since the value
of ISBN is not generated by the database we need to use Database Generated Values.
It has three options :
</p>
<ol>
<li>None - database is not generating values for this property</li>
<li>Identity - means the corresponding column in the database is an identity column </li>
<li>Computed - the target column is a computed column in the database
(for example we might have a computed column called full name that combines first and last name)</li>
</ol>
<pre>
  [Key]
  [DatabaseGenerated(DatabaseGeneratedOption.None)]
  public string Name {get; set;}
</pre>

<h3>Composite Keys</h3>
<p> This means we will have more than 1 key, we will aply Key in both of them
  and column order.
</p>
<pre>
  public class OrderItem
  {
    [Key]
    [Column(Order = 1)]
    public int OrderId{get;set;}

    [Key]
    [Column(Order = 2)]
    public int OrderItemId{get;set;}
  }
</pre>

<h3>Nulls</h3>
<p> A column is nullable if property is nullable. We need to tell entity framework
  that a column must not be nullable. It 's just an annotation. It doesn't
  stop you to have it null in your C# but you will get exception error.
</p>
<pre>
[Required]
public string Name {get; set;}
</pre>

<h3>Length of strings</h3>
<p>If you want to change the length of your column use Maxlength.
</p>
<pre>
[MaxLength(255)]
public string Name {get; set;}
</pre>

<h3>Index</h3>
<p>You can add an Index by simply using Index keyword. If you want to ensure
  that you don't have two users, courses etc with the same name you
  amke them unique.
</p>
<pre>
[Index(IsUnique = true)]
public string Name {get; set;}
</pre>
<p>If you have multiple indexes you need to specify the name of the index and order for the columns in the index.
</p>
<pre>
[Index("IX_AuthorStudentsCount",1)]
public int AuthorId {get; set;}

[Index("IX_AuthorStudentsCount",2)]
public int StudentsCount {get; set;}

</pre>

<h3>Foreign Keys</h3>
<ol>
<li>first we add a foreign key property with the desired name</li>
<li>We need to link this property to the Author property which is a navigation property.</li>
It allows us to navigate from a course object to an author object.
</ol>
<p>If you don't link these columns entity framework will create two columns
one called Author_Id and another one AuthorId. We have two ways of achieving that.
</p>
<pre>
  public class Course
  {
    [ForeignKey("Author")]
    public int AuthorId{get; set;}

    public Author Author;
  }
</pre>
<pre>
  public class Course
  {
    public int AuthorId{get; set;}

    [ForeignKey("AuthorId")]
    public Author Author;
  }
</pre>




</section>
<section>
<h2>Fluent API</h2>
<p>Let's say we have a nullable convention like shown here.
<img src="overriding_convention.jpg">
</p>

<p>This is where we use Fluent API to override conventions in Enity framework.
<img src="onmodelcreating.jpg">
</p>
<ol>
<li>We start with model builder</li>
<li>Then the entity method which is a generic method with
the entity we will use
</li>
<li>Chain methods(that's why it s called fluent API,make your own story)</li>
<li>method and Lambda expression</li>
<li>Add migration</li>
<li>Update database</li>
</ol>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
      modelBuilder.Entity&lt;Course>()
                  .Property(t => t.Description)
                  .IsRequired();

}
</pre>
<p>
In the above we say at Course table make the property Description required.
</p>

<h2>Table Names</h2>
<p>To override a table in the database we can call the method ToTable().If you wa
to change the table schema for this table we pass an extra argument.</p>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
      modelBuilder.Entity&lt;Course>()
                  .ToTable("tbl_Course","catalog");
}
</pre>

<h2>Primary Keys</h2>
<p>To configure primary keys we use the HasKey method which takes a lambda expression.</p>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
      modelBuilder.Entity&lt;Book>()
                  .HasKey(t=>t.ISBN);
}
</pre>

<h2>Composite Keys</h2>
<p>Again we use the HasKey method. In the lamda expression we use an anonymous object
and supply the name pf properties.
</p>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
      modelBuilder.Entity&lt;Book>()
                  .HasKey(t=>new{t.OrderId,t.OrderItemId });
}
</pre>

<h2>Column Names</h2>
<p>First we call the property method whic htakes a lambda expression
  that defines the name of the property and then we chain another method
  HasColumnName.
</p>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
      modelBuilder.Entity&lt;Course>()
                  .Property(t=>t.Name)
                  .HasColumnName("sName");
}
</pre>
<p>To change type of the column: </p>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
      modelBuilder.Entity&lt;Course>()
                  .Property(t=>t.Name)
                  .HasColumnType("varchar");
}
</pre>

<h2>Column Orders</h2>
<p>We also have a method to change columns order.
</p>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
        modelBuilder.Entity&lt;Course>()
                    .Property(t=>t.Name)
                    .HasColumnOrder(2);
}
</pre>

<h2>Database Generated</h2>
<p>We also have a method for keys that we don't want to be assigned automatically like Primary Key in data
  annotation.
</p>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
        modelBuilder.Entity&lt;Course>()
                    .Property(t=>t.ISBN)
                    .HasDatabaseGeneratedOption(DatabaseGeneratedOption.None)
}
</pre>

<h2>Nulls</h2>
<p>A method called IsRequired to not let nulls.
</p>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
        modelBuilder.Entity&lt;Course>()
                    .Property(t=>t.ISBN)
                    .IsRequired();
}
</pre>

<h2>Lenth of Strings</h2>
<p>A method called HasMaxLength.
</p>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
        modelBuilder.Entity&lt;Course>()
                    .Property(t=>t.ISBN)
                    .HasMaxLength(255);
}
</pre>

<p>Set type to max:</p>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
        modelBuilder.Entity&lt;Course>()
                    .Property(t=>t.ISBN)
                    .IsMaxLength();
}
</pre>

<h2>Relationships</h2>
<p>This where Fluent API shines over data annotations.From type 1 to Type 2.</p>

<ol>
<li>HasMany - If object has many relations to object 2</li>
<li>HasRequired - if object 1 has only one object of type 2</li>
<li>HasOptional - if object 1 one has 0 or 1 objects of type 2</li>
</ol>

<p>Reverse direction.From type 2 to Type 1.</p>

<ol>
<li>WithMany - If object 2 has many relations to object 1</li>
<li>WithRequired - if object 2 has only one object of type 1</li>
<li>HasOptional - if object 2 one has 0 or 1 objects of type 1</li>
</ol>

<p>Examples : </p>
<ol>
<li>One-To-many - Author -> Book(An author can have many books)
From left to right we will have :
<pre>
modelBuilder.Entity&lt;Author>()
            .HasMany(a => Books)
</pre>
Then we need the reverse order which represents that Books must have an author :
<pre>
modelBuilder.Entity&lt;Author>()
            .HasMany(a => Books)
            .WithRequired(c=> c.Author)
</pre>
Also we can optionally specify a foreign key :
<pre>
modelBuilder.Entity&lt;Author>()
            .HasMany(a => Books)
            .WithRequired(c=> c.Author)
            .HasForeignKey(c=>c.AuthorId);
</pre>
If we change the properties in the Books class since we use lamda expressions
they will be automatically be updated in here. Also we can set cascade
on delete to false which means if you have an author and this author
have at least one book we shouldn't be able to dlete this author.
<pre>
modelBuilder.Entity&lt;Author>()
            .HasMany(a => Books)
            .WithRequired(c=> c.Author)
            .HasForeignKey(c=>c.AuthorId)
            .WillCascadeOnDelete(false);
</pre>
</li>
<li>Many-to-many - Customers->Products (Each customer can purchase many
  products, and each of those products can be purchased
  by many different customers)
<pre>
modelBuilder.Entity&lt;Customer>()
            .HasMany(c => c.Orders)
            .WithMany(p=> p.Customers)
            .Map(m=>m.ToTable("CustomersOrders"))
</pre>
You need to write this code only if you need to supply additional information
for this many to many relationship. If we had name of table that looked
strange we could override it.<br>
<strong>Advanced Configurations</strong>
<pre>
  modelBuilder.Entity<Course>()
                       .HasMany(c => c.Tags)
                       .WithMany(c => c.Courses)
                       .Map(m =>
                       {
                           m.ToTable("CourseTags");
                           //Since we start from Course the left side is Course
                           //The name of the left key is going to be CourseId
                           m.MapLeftKey("CourseId");
                           //The name of the left key is going to be TagId
                           m.MapRightKey("TagId");
                       });
</pre>
</li>
<li>one-to-zero/one - Course -> Caption(a course can optionally have
a caption but a caption can only belong to one course)
<pre>
modelBuilder.Entity&lt;Course>()
            .HasOptional(c=>c.Caption)
            .WithRequired(c => c.Course);
</pre>
<strong>So in general we start with the Has method and we continue with
  the With method.
 </strong>
</li>

<li>One-to-one - Course->Cover
  (A Course has one cover and a cover belongs to one course)In theis example Course is
  the parent and Cover is the child. In enity framewrok are called Principal and Dependent.
<pre>
modelBuilder.Entity&lt;Course>()
            .HasRequired(c => c.Cover)
            .WithRequiredPrincipal(c => c.Course);
</pre>
When we have one-to-one relationship we must use With method to let entity framework know who is the parent
and who is the child. And reverse :

<pre>
modelBuilder.Entity&lt;Course>()
            .HasRequired(c => c.Course)
            .WithRequiredDependent(c => c.Cover);
</pre>
</li>


</ol>

<h3>Organizing FluentApiConfigurations</h3>

<p>Making many changes to your DbContext slowly it will make it big
and hard to maintain. You will have to create a class for
each congiguration class. In the below code all changes apply to Course class.

</p>

<pre>
  protected override void OnModelCreating(DbModelBuilder modelBuilder)
  {
      modelBuilder.Entity<Course>()
                 .Property(c => c.Name)
                 .IsRequired()
                 .HasMaxLength(255);

      //Change max length for Description in Courses
      modelBuilder.Entity<Course>()
                  .Property(c => c.Description)
                  .HasMaxLength(2000);

      //Change Courses foreign key Author_Id to AuthorId
      //And if an author has a course not let to be delete
      modelBuilder.Entity<Course>()
                  .HasRequired(c => c.Author)
                  .WithMany(a => a.Courses)
                  .HasForeignKey(c => c.AuthorId)
                  .WillCascadeOnDelete(false);

      //Change name of table TagCourses(was created in database automatically) to CoursesTag
      modelBuilder.Entity<Course>()
                  .HasMany(c => c.Tags)
                  .WithMany(c => c.Courses)
                  .Map(m =>
                  {
                      m.ToTable("CourseTags");
                      //Since we start from Course the left side is Course
                      //The name of the left key is going to be CourseId
                      m.MapLeftKey("CourseId");
                      //The name of the left key is going to be TagId
                      m.MapRightKey("TagId");
                  });

      //New table cover and relationship with Course
      modelBuilder.Entity<Course>()
                  .HasRequired(c => c.Cover)
                  .WithRequiredPrincipal(c => c.Course);


      base.OnModelCreating(modelBuilder);
  }


</pre>
<p>You will have to create a new folder in your project and call it
EntityConfigurations. We will create there a class NameOfEntityConfigurations. And the above will
look like this
 </p>

<pre>
  using System;
  using System.Collections.Generic;
  using System.Data.Entity.ModelConfiguration;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;

  namespace FluentAPI.EntityConfigurations
  {
      public class CourseConfiguration : EntityTypeConfiguration<Course>
      {
          public CourseConfiguration()
          {

                         Property(c => c.Name)
                         .IsRequired()
                         .HasMaxLength(255);

              //Change max length for Description in Courses

                          Property(c => c.Description)
                          .HasMaxLength(2000);

              //Change Courses foreign key Author_Id to AuthorId
              //And if an author has a course not let to be delete

                          HasRequired(c => c.Author)
                          .WithMany(a => a.Courses)
                          .HasForeignKey(c => c.AuthorId)
                          .WillCascadeOnDelete(false);

              //Change name of table TagCourses(was created in database automatically) to CoursesTag

                          HasMany(c => c.Tags)
                          .WithMany(c => c.Courses)
                          .Map(m =>
                          {
                              m.ToTable("CourseTags");
                              //Since we start from Course the left side is Course
                              //The name of the left key is going to be CourseId
                              m.MapLeftKey("CourseId");
                              //The name of the left key is going to be TagId
                              m.MapRightKey("TagId");
                          });

              //New table cover and relationship with Course

                          HasRequired(c => c.Cover)
                          .WithRequiredPrincipal(c => c.Course);

          }
      }
  }

</pre>
<p>How to organize these changes . Alhabetically and :</p>
<ol>
<li>Table overrides ex - ToTable("Bob")</li>
<li>Primary keys ex - HasKey(c =>c.Id)</li>
<li>Property configurations</li>
<li>Relationships</li>
</ol>

<p>Finally we need to reference the configurtation class.</p>
<pre>
  using FluentAPI.EntityConfigurations;
  using System.Data.Entity;

  namespace FluentAPI
  {
      public class FluentAPIContext :DbContext
      {
          public virtual DbSet<Author> Authors { get; set; }
          public virtual DbSet<Course> Courses { get; set; }
          public virtual DbSet<Tag> Tags { get; set; }

          protected override void OnModelCreating(DbModelBuilder modelBuilder)
          {
              modelBuilder.Configurations.Add(new CourseConfiguration());
          }

      }
  }
</pre>
<h3>What to use?</h3>
<p>Database annnotations is simpler but more limited. Fluent API is stronger and you can do
more stuff with it. Also Fluent API is more cleaner since it doesn;t pollutes
the class itself.<br><strong> Do not mix these two approaches.</strong>
</p>
</section>
