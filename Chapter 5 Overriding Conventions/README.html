
<h1>Overriding Conventions</h1>
<section>
<h2>Data annotation</h2>
<p>Let's say we have a nullable convention like shown here.
<img src="overriding_convention.jpg">
We want to override this convention and make sure that every course has a description.
We go to CodeFirstExistingDatabase at Course class.
<pre>
[Required]
public string Description { get; set; }
</pre>
</p>

<p>Also we need using System.ComponentModel.DataAnnotations; </p>
<p>Back to package manager console to add the migration and we see what the migration created.

<img src="nullable_false_created.jpg">
</p>

<p>If we want this change we apply the migration by updating database.</p>

<h3>Table Names</h3>
<p>If you have a class Course the table name must be Courses. You can define the Schema
also if it isn't in dbo.</p>
<pre>
  [Table("Courses").Schema ="catalog"]
  public partial class Course
</pre>

<h3>Column Names</h3>
<p>The convention assumes the property is the same with the column.
If you want to use different table name and different type you wil have the following code.
</p>
<pre>
  [Column("sName",TypeName="varchar")]
  public string Name {get; set;}
</pre>

<h3>Primary Key</h3>
<p>The convention assumes that if you have a property Id or the nameo of the class plus Id
it will be the primary key. It s an integer and identity column. If we have something like ISBN we
need to tell entity framework that this property will be the Id. Since the value
of ISBN is not generated by the database we need to use Database Generated Values.
It has three options :
</p>
<ol>
<li>None - database is not generating values for this property</li>
<li>Identity - means the corresponding column in the database is an identity column </li>
<li>Computed - the target column is a computed column in the database
(for example we might have a computed column called full name that combines first and last name)</li>
</ol>
<pre>
  [Key]
  [DatabaseGenerated(DatabaseGeneratedOption.None)]
  public string Name {get; set;}
</pre>

<h3>Composite Keys</h3>
<p> This means we will have more than 1 key, we will aply Key in both of them
  and column order.
</p>
<pre>
  public class OrderItem
  {
    [Key]
    [Column(Order = 1)]
    public int OrderId{get;set;}

    [Key]
    [Column(Order = 2)]
    public int OrderItemId{get;set;}
  }
</pre>

<h3>Nulls</h3>
<p> A column is nullable if property is nullable. We need to tell entity framework
  that a column must not be nullable. It 's just an annotation. It doesn't
  stop you to have it null in your C# but you will get exception error.
</p>
<pre>
[Required]
public string Name {get; set;}
</pre>

<h3>Length of strings</h3>
<p>If you want to change the length of your column use Maxlength.
</p>
<pre>
[MaxLength(255)]
public string Name {get; set;}
</pre>

<h3>Index</h3>
<p>You can add an Index by simply using Index keyword. If you want to ensure
  that you don't have two users, courses etc with the same name you
  amke them unique.
</p>
<pre>
[Index(IsUnique = true)]
public string Name {get; set;}
</pre>
<p>If you have multiple indexes you need to specify the name of the index and order for the columns in the index.
</p>
<pre>
[Index("IX_AuthorStudentsCount",1)]
public int AuthorId {get; set;}

[Index("IX_AuthorStudentsCount",2)]
public int StudentsCount {get; set;}

</pre>

<h3>Foreign Keys</h3>
<ol>
<li>first we add a foreign key property with the desired name</li>
<li>We need to link this property to the Author property which is a navigation property.</li>
It allows us to navigate from a course object to an author object.
</ol>
<p>If you don't link these columns entity framework will create two columns
one called Author_Id and another one AuthorId. We have two ways of achieving that.
</p>
<pre>
  public class Course
  {
    [ForeignKey("Author")]
    public int AuthorId{get; set;}

    public Author Author;
  }
</pre>
<pre>
  public class Course
  {
    public int AuthorId{get; set;}

    [ForeignKey("AuthorId")]
    public Author Author;
  }
</pre>




</section>
<section>
<h2>Fluent API</h2>
<p>Let's say we have a nullable convention like shown here.
<img src="overriding_convention.jpg">
</p>

<p>This is where we use Fluent API to override conventions in Enity framework.
<img src="onmodelcreating.jpg">
</p>
<ol>
<li>We start with model builder</li>
<li>Then the entity method which is a generic method with
the entity we will use
</li>
<li>Chain methods(that's why it s called fluent API,make your own story)</li>
<li>method and Lambda expression</li>
<li>Add migration</li>
<li>Update database</li>
</ol>
<pre>
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
      modelBuilder.Entity<Course>()
                  .Property(t => t.Description)
                  .IsRequired();

}
</pre>
<p>
In the above we say at Course table make the property Description required.
</p>
<h3>What to use?</h3>
<p>Database annnotations is simpler but more limited. Fluent API is stronger and you can do
more stuff with it. Also Fluent API is more cleaner since it doesn;t pollutes
the class itself.<br><strong> Do not mix these two approaches.</strong>
</p>
</section>
